# Exploit Payloads Reference

This document contains actual attack payloads used during penetration testing.
Use these to verify fixes are effective.

---

## CRITICAL: Denial of Service Exploits

### Payload 1: Infinite Retry Loop
```typescript
// MALICIOUS CONFIGURATION
const dosPayload = {
    maxAttempts: -1,              // ← EXPLOIT: Negative value
    backoffType: 'exponential',
    baseDelayMs: 0,
    maxDelayMs: 0,
    retryableErrors: [],
    jitter: false
};

// EXPECTED BEHAVIOR (VULNERABLE):
// - Loop executes indefinitely
// - Thread hangs consuming CPU
// - Service becomes unresponsive

// EXPECTED BEHAVIOR (FIXED):
// - Throws: "maxAttempts must be between 1 and 100"
```

### Payload 2: CPU Exhaustion
```typescript
const cpuExhaustPayload = {
    maxAttempts: 10000,           // ← EXPLOIT: Very large
    backoffType: 'fixed',
    baseDelayMs: 0,               // ← EXPLOIT: No delay
    maxDelayMs: 0,
    retryableErrors: [],
    jitter: false
};

// IMPACT: 10,000 retries in <1 second
// CPU usage spikes to 100%
```

### Payload 3: Integer Overflow
```typescript
const overflowPayload = {
    maxAttempts: Number.MAX_SAFE_INTEGER,  // ← EXPLOIT: 9,007,199,254,740,991
    backoffType: 'exponential',
    baseDelayMs: 1000,
    maxDelayMs: 5000,
    retryableErrors: [],
    jitter: false
};

// IMPACT: Effectively infinite retries
```

---

## CRITICAL: Information Disclosure Exploits

### Payload 4: Credential Extraction
```typescript
// MALICIOUS ERROR MESSAGE
throw new Error(
    'Authentication failed for ' +
    'postgresql://admin:SuperSecret123@prod-db.internal:5432/payments'
);

// LEAKED INFORMATION:
// - Username: admin
// - Password: SuperSecret123
// - Hostname: prod-db.internal
// - Port: 5432
// - Database: payments
```

### Payload 5: AWS Key Leakage
```typescript
throw new Error(
    'AWS authentication failed: ' +
    'AKIAIOSFODNN7EXAMPLE ' +
    'wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY'
);

// LEAKED:
// - AWS Access Key ID: AKIAIOSFODNN7EXAMPLE
// - AWS Secret Key: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
```

### Payload 6: JWT Token Leakage
```typescript
throw new Error(
    'Authorization failed: Bearer ' +
    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.' +
    'eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.' +
    'SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c'
);

// LEAKED: Full JWT token with payload
```

### Payload 7: Stack Trace Reconnaissance
```typescript
const err = new Error('Internal server error');
err.stack = `Error: Internal server error
    at PaymentProcessor.charge (/app/src/billing/stripe-integration.js:142:15)
    at validateCard (/app/src/billing/validators/credit-card.js:89:23)
    at decrypt (/app/src/crypto/aes-256-gcm.js:45:10)
    at Database.query (/app/node_modules/pg/lib/client.js:234:7)
    at RedisCache.get (/app/node_modules/redis/lib/client.js:167:3)`;

throw err;

// LEAKED ARCHITECTURE:
// - Technology: Stripe integration
// - Crypto: AES-256-GCM
// - Database: PostgreSQL (pg module)
// - Cache: Redis
// - File structure: /app/src/billing/
```

---

## HIGH: Regular Expression Denial of Service (ReDoS)

### Payload 8: Catastrophic Backtracking
```typescript
const redosPayload = {
    maxAttempts: 3,
    backoffType: 'fixed',
    baseDelayMs: 100,
    maxDelayMs: 1000,
    retryableErrors: [
        '(a+)+b',           // ← EXPLOIT: Catastrophic backtracking
        '(a|a)*',           // ← EXPLOIT: Redundant alternation
        '(a|ab)*',          // ← EXPLOIT: Overlapping patterns
        '([a-zA-Z]+)*'      // ← EXPLOIT: Nested quantifiers
    ],
    jitter: false
};

// Attack string (no 'b' to match pattern)
const attackString = 'a'.repeat(30);

// IMPACT:
// - Exponential time complexity: O(2^n)
// - 30 characters = 1,073,741,824 operations
// - CPU exhaustion for seconds/minutes
```

### Payload 9: Lookbehind Attack
```typescript
const lookbehindPayload = {
    retryableErrors: [
        '(?<=a+)b',         // ← EXPLOIT: Positive lookbehind
        '(?<!a+)b',         // ← EXPLOIT: Negative lookbehind
    ]
};

// IMPACT: Slower regex engine, potential DoS
```

---

## HIGH: Input Validation Bypasses

### Payload 10: Negative Delay
```typescript
const negativeDelayPayload = {
    maxAttempts: 100,
    backoffType: 'fixed',
    baseDelayMs: -1000,         // ← EXPLOIT: Negative value
    maxDelayMs: -500,           // ← EXPLOIT: Negative value
    retryableErrors: [],
    jitter: false
};

// IMPACT: Bypasses rate limiting, immediate retries
```

### Payload 11: Special Characters in Operation ID
```typescript
const injectionPayload = {
    operationId: [
        '../../../etc/passwd',              // Path traversal
        '\x00\r\n\t',                       // Null bytes, control chars
        '<script>alert(1)</script>',        // XSS attempt
        '"; DROP TABLE users; --',          // SQL injection attempt
        '${process.env.SECRET_KEY}',        // Template injection
        '../../config/database.yml'         // Config file access
    ].join('')
};

// IMPACT: Log injection, file access, potential XSS
```

---

## MEDIUM: Timing Attacks

### Payload 12: Error Type Fingerprinting
```typescript
// Test different error types to measure timing
const timingAttack = async () => {
    const results = [];

    // Retryable error (will retry 3 times)
    const start1 = Date.now();
    try {
        await executor.executeWithRetry(
            () => { throw new Error('ETIMEDOUT'); },
            policy
        );
    } catch {}
    results.push({ type: 'retryable', duration: Date.now() - start1 });

    // Non-retryable error (fails immediately)
    const start2 = Date.now();
    try {
        await executor.executeWithRetry(
            () => { throw new Error('Invalid input'); },
            policy
        );
    } catch {}
    results.push({ type: 'non-retryable', duration: Date.now() - start2 });

    // ANALYSIS: Duration difference reveals error classification
    const diff = Math.abs(results[0].duration - results[1].duration);
    console.log(`Timing difference: ${diff}ms`);
    console.log('Error type can be determined via timing');

    return results;
};

// LEAKED INFORMATION:
// - Which errors are retryable
// - Internal retry logic
// - Error classification rules
```

### Payload 13: Retry Count Detection
```typescript
const detectRetryCount = async () => {
    const policy = {
        maxAttempts: 10,
        backoffType: 'exponential',
        baseDelayMs: 100,
        maxDelayMs: 60000,
        retryableErrors: [],
        jitter: false  // ← Required for precise timing
    };

    const start = Date.now();
    let retryCount = 0;

    try {
        await executor.executeWithRetry(async () => {
            retryCount++;
            if (retryCount < 5) throw new Error('ETIMEDOUT');
            return 'ok';
        }, policy);
    } catch {}

    const duration = Date.now() - start;

    // Calculate retries from timing
    // Exponential backoff: 100, 200, 400, 800 = 1500ms for 4 retries
    const calculatedRetries = Math.floor(Math.log2((duration / 100) + 1));

    console.log(`Actual retries: ${retryCount}`);
    console.log(`Calculated from timing: ${calculatedRetries}`);
    console.log('Retry count leaked via timing signature');
};

// LEAKED INFORMATION:
// - Exact number of retries
// - Retry policy configuration
// - Operation success/failure patterns
```

---

## MEDIUM: Race Conditions

### Payload 14: Concurrent ID Collision
```typescript
const raceConditionAttack = async () => {
    const sharedId = 'shared-operation-id';

    // Launch two operations with same ID simultaneously
    const op1 = executor.executeWithRetry(
        async () => {
            await sleep(10);
            throw new Error('Error from operation 1');
        },
        policy,
        sharedId  // ← Same ID
    );

    const op2 = executor.executeWithRetry(
        async () => {
            await sleep(10);
            throw new Error('Error from operation 2');
        },
        policy,
        sharedId  // ← Same ID
    );

    try {
        await Promise.all([op1, op2]);
    } catch {}

    // CHECK: State corruption
    const state = executor.getRetryState(sharedId);
    console.log('Final state (may be corrupted):', state);

    // IMPACT:
    // - Undefined behavior
    // - State corruption
    // - Inconsistent retry counts
};
```

### Payload 15: Cancel During Execution
```typescript
const cancelAttack = async () => {
    const opId = 'cancel-test';
    let operationStillRunning = false;

    const operation = executor.executeWithRetry(async () => {
        await sleep(50);
        operationStillRunning = true;
        console.log('Operation executed (should have been cancelled!)');
        throw new Error('ETIMEDOUT');
    }, policy, opId);

    // Cancel after 25ms (while operation is running)
    setTimeout(() => {
        const cancelled = executor.cancelRetry(opId);
        console.log(`Cancelled: ${cancelled}`);
    }, 25);

    try {
        await operation;
    } catch {}

    console.log(`Operation still ran: ${operationStillRunning}`);

    // IMPACT:
    // - Cancel doesn't actually stop execution
    // - Resources not freed
    // - Operations continue consuming CPU
};
```

---

## MEDIUM: Event Listener Memory Leak

### Payload 16: Listener Accumulation
```typescript
const memoryLeakAttack = async () => {
    const executor = new RetryExecutor();
    const policy = { maxAttempts: 2, baseDelayMs: 1 };

    const initialMemory = process.memoryUsage().heapUsed;
    const listeners = [];

    // EXPLOIT: Register 10,000 listeners
    for (let i = 0; i < 10000; i++) {
        const listener = (data: any) => {
            listeners.push(data); // Accumulate data
        };
        executor.on('retry_attempt', listener);

        // Sometimes don't remove (leak)
        if (i % 3 !== 0) {
            executor.removeListener('retry_attempt', listener);
        }
    }

    // Trigger events
    for (let i = 0; i < 100; i++) {
        try {
            await executor.executeWithRetry(
                () => { throw new Error('ETIMEDOUT'); },
                policy,
                `op-${i}`
            );
        } catch {}
    }

    const finalMemory = process.memoryUsage().heapUsed;
    const leaked = (finalMemory - initialMemory) / 1024 / 1024;

    console.log(`Memory leaked: ${leaked.toFixed(2)}MB`);
    console.log(`Events accumulated: ${listeners.length}`);

    // IMPACT:
    // - >1MB memory leak
    // - 100k+ accumulated events
    // - Eventually causes OOM crash
};
```

---

## Testing Instructions

### Verify Vulnerability (Before Fix)
```bash
# Each exploit should succeed
npm test -- tests/security/retry-penetration-test.ts

# Expected: All exploits work
```

### Verify Fix (After Fix)
```bash
# Each exploit should fail with validation error
npm test -- tests/security/retry-penetration-test.ts

# Expected: All exploits blocked
```

### Individual Payload Testing
```typescript
import { RetryExecutor } from '../src/orchestration/RetryStrategy';

// Test specific payload
const executor = new RetryExecutor();

try {
    await executor.executeWithRetry(
        () => { throw new Error('test'); },
        { maxAttempts: -1 }  // ← Payload 1
    );
    console.log('VULNERABLE: Exploit succeeded');
} catch (error) {
    console.log('SECURE: Exploit blocked:', error.message);
}
```

---

## Appendix: Attack Success Indicators

| Indicator | Vulnerable System | Secure System |
|-----------|------------------|---------------|
| Infinite loop | Process hangs | ValidationError thrown |
| CPU exhaustion | 100% CPU usage | Max 10ms minimum delay |
| Credential leak | Passwords in logs | `***` redacted |
| Stack trace leak | Full paths shown | Message only |
| Memory leak | Heap grows >1MB | Stable memory |
| ReDoS | Seconds delay | Instant rejection |
| Race condition | Inconsistent state | Mutex protected |
| Cancel fails | Operation continues | Aborted immediately |

---

**Security Status**: All payloads MUST be blocked after remediation.
**Validation**: Run full test suite to confirm fixes.
